# üõ°Ô∏è **Limiting S3 Access to CloudFront Only ‚Äì Two Scenarios Explained**

> Ensure your S3 bucket content is **always accessed securely**, either **through CloudFront only** or **by authenticated users** via signed URLs/cookies.

---

## üß≠ SCENARIO 1: Public Content ‚Äì Limit Access to CloudFront Only via OAC

You want to prevent **direct access to your S3 bucket** but still serve content **publicly** through CloudFront (e.g., public images, videos, static files).

### ‚úÖ Solution: **Use Origin Access Control (OAC)**

---

<div align="center">
  <img src="images/s3-cloudfront-oac.png" alt="CloudFront OAC S3" style="border-radius: 10px; width: 60%;" />
</div>

---

### üîí How It Works

- You enable **OAC** in your CloudFront distribution.
- CloudFront signs all requests to S3 with an **IAM-style signature**.
- Your S3 bucket **blocks public access** and allows **only signed requests** from CloudFront.

---

### üìú Example S3 Bucket Policy

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowCloudFrontAccessOnly",
      "Effect": "Allow",
      "Principal": {
        "Service": "cloudfront.amazonaws.com"
      },
      "Action": "s3:GetObject",
      "Resource": "arn:aws:s3:::your-bucket-name/*",
      "Condition": {
        "StringEquals": {
          "AWS:SourceArn": "arn:aws:cloudfront::<account-id>:distribution/<distribution-id>"
        }
      }
    }
  ]
}
```

> Replace `your-bucket-name`, `<account-id>`, and `<distribution-id>` with your actual values.

---

### ‚úÖ Best Practices

| ‚úÖ Best Practice                    | üîç Why It Matters                                 |
| ----------------------------------- | ------------------------------------------------- |
| Enable **Block Public Access**      | Prevents users from bypassing CloudFront          |
| Use **OAC** instead of legacy OAI   | OAC supports modern IAM controls & signed headers |
| Sign origin requests in CloudFront  | Ensures only CloudFront can retrieve objects      |
| Use **HTTPS** from CloudFront to S3 | Secure transport between edge and origin          |

---

## üîê SCENARIO 2: Private Content ‚Äì Serve Authenticated Users Only

You need to serve **private S3 content**, such as:

- Paid media (video, audio)
- PDFs for logged-in users
- Confidential reports

### ‚úÖ Solution: **Use Signed URLs or Signed Cookies**

---

<div style="text-align: center;">
    <img src="images/serving-private-content-via-CloudFront.png" alt="Serving Private Content via CloudFront" style="border-radius: 10px;" />
</div>

---

### üîÅ How It Works

1. Your app generates a **signed URL** (or cookie).
2. User accesses CloudFront with that signature.
3. CloudFront verifies the signature using a **key group**.
4. If valid, it retrieves the object from S3 via OAC (private bucket).

---

### üßæ Signed URL vs. Signed Cookie

| Feature         | Signed URLs üîó            | Signed Cookies üç™                              |
| --------------- | ------------------------- | ---------------------------------------------- |
| Scope           | Individual file           | Multiple files                                 |
| Use Case        | One-time download         | Web apps with multiple assets (e.g. streaming) |
| Cookie Required | No                        | Yes                                            |
| Flexibility     | Easy to generate per-file | Easier for session-based access                |

---

### üß† Architecture Flow

```mermaid
sequenceDiagram
    participant User
    participant YourApp
    participant CloudFront
    participant S3

    User->>YourApp: Request content
    YourApp->>CloudFront: Return signed URL/cookie
    User->>CloudFront: Access with signature
    CloudFront->>S3: Fetch if valid (OAC signed)
    S3-->>CloudFront: Object
    CloudFront-->>User: Serve content
```

---

### üõ†Ô∏è Setup Overview

#### 1. Generate Key Pair

```bash
openssl genrsa -out private_key.pem 2048
openssl rsa -pubout -in private_key.pem -out public_key.pem
```

#### 2. Upload Public Key in CloudFront

- Console ‚Üí **CloudFront ‚Üí Public Keys**
- Create **Key Group** ‚Üí attach to your distribution

#### 3. Restrict Access Behavior

- Edit distribution behavior:

  - Viewer access: **Restrict by Signed URL/Cookie**
  - Attach your key group

---

### ‚úçÔ∏è Signed URL Generation (Python)

```python
from aws_cloudfront_signer import CloudFrontSigner
import rsa
from datetime import datetime, timedelta

def rsa_signer(message):
    with open("private_key.pem", "rb") as key_file:
        private_key = rsa.PrivateKey.load_pkcs1(key_file.read())
    return rsa.sign(message, private_key, 'SHA-1')

signer = CloudFrontSigner("KEY_ID", rsa_signer)

signed_url = signer.generate_presigned_url(
    "https://your-distribution.cloudfront.net/private/file.pdf",
    date_less_than=datetime.utcnow() + timedelta(hours=1)
)

print(signed_url)
```

---

### ‚úÖ Best Practices for Private Access

| Recommendation                      | Reason                                       |
| ----------------------------------- | -------------------------------------------- |
| Use **short TTLs** for signed URLs  | Limits risk of unauthorized sharing          |
| Store **private keys securely**     | Use Secrets Manager or environment variables |
| Monitor access with **CloudTrail**  | Detect suspicious behavior or abuse          |
| Restrict viewer access to **HTTPS** | Prevent plain HTTP leaks                     |

---

## üì¶ Summary: Choose the Right Option

| Scenario                   | Method Used            | Description                                  |
| -------------------------- | ---------------------- | -------------------------------------------- |
| Public but secured via CDN | OAC + CloudFront       | Restrict direct access, serve via CloudFront |
| Private user-based content | Signed URLs or Cookies | Provide temporary, authenticated access      |
