# ğŸ”ŒğŸŒ **Amazon API Gateway â€“ Integration Types & Mapping Templates**

> In API Gateway, **integration types** define **how your API connects to its backend** (Lambda, HTTP service, or even nothing).
> You can also use **mapping templates** to reshape the request and response payloads as needed.

---

<div style="text-align: center;">
    <img src="images/agw-integrations.png" alt="API Gateway Integration Types" style="border-radius: 10px; width: 60%;">
</div>

## âš™ï¸ **Integration Types Overview**

There are **5 integration types** you can use in REST APIs:

| Integration Type | Purpose                                               | Mapping Supported? |
| ---------------- | ----------------------------------------------------- | ------------------ |
| ğŸ§ª `MOCK`        | Simulate responses without any backend                | âœ… Yes             |
| ğŸŒ `HTTP`        | Send requests to public/private HTTP backend          | âœ… Yes             |
| ğŸ§° `AWS`         | Connect to AWS services (e.g., Lambda, SQS, DynamoDB) | âœ… Yes             |
| âš¡ `AWS_PROXY`   | Invoke Lambda via **Lambda Proxy** integration        | âŒ No              |
| ğŸ”„ `HTTP_PROXY`  | Proxy directly to an HTTP endpoint                    | âŒ No              |

Letâ€™s dive into each:

---

<div style="text-align: center;">
    <img src="images/agw-integrations-types.png" alt="API Gateway Integration Types" style="border-radius: 10px; width: 60%;">
</div>

---

### ğŸ”® **1. MOCK Integration**

> Use when you want **API Gateway to return a response without contacting any backend**.

ğŸ“Œ Great for:

- Prototyping
- Returning static responses
- Testing request/response mapping

âœ… **Supports full mapping templates** for simulating custom behavior.

---

### ğŸŒ **2. HTTP Integration**

> For calling **HTTP endpoints** (on-prem, internal, public).

You can:

- Send requests to a server like `https://api.company.com/data`
- Map path/query params, body, and headers
- Transform backend responses before sending to the client

> âœ… You control everything using **mapping templates**.

---

### ğŸ§° **3. AWS Integration**

> Used to **call AWS services directly** (e.g., SQS, DynamoDB, Step Functions).

---

<div style="text-align: center;">
    <img src="images/agw-aws-integration.png" alt="API Gateway AWS Integration" style="border-radius: 10px; width: 60%;">
</div>

---

You specify:

- The ARN of the service
- IAM role with permissions
- Any headers or parameters needed by the service

> âœ… Also supports **mapping templates** for full control.

---

### âš¡ **4. Lambda Proxy Integration (AWS_PROXY)**

> API Gateway **forwards the entire request directly to Lambda**
> Lambda returns a **structured JSON response** back to API Gateway.

ğŸ“¦ You get this structure in your Lambda:

```json
{
  "resource": "/example",
  "path": "/example",
  "httpMethod": "GET",
  "headers": { ... },
  "queryStringParameters": { ... },
  "body": "{...}",
  "isBase64Encoded": false
}
```

> âœ… Simple setup  
> âŒ **No mapping templates** â€” Lambda must do everything.

---

### ğŸ”„ **5. HTTP Proxy Integration**

> API Gateway **forwards the HTTP request as-is** to a backend HTTP endpoint, and forwards the response directly to the client.
> Fast and low-config

---

> âœ… Useful for lifting legacy REST APIs behind an API Gateway
> âŒ Cannot modify requests or responses

---

## ğŸ§ª **Mapping Templates â€“ What & Why**

> A **mapping template** lets you **transform the request/response body** and headers between client and backend.

It uses **Velocity Template Language (VTL)**:

- Supports variables, conditionals, loops
- Extract headers, query params, path params
- Modify JSON/XML payloads

---

### ğŸ§± Use Cases

| Goal                                | Mapping Needed?    | Example                              |
| ----------------------------------- | ------------------ | ------------------------------------ |
| Rename query parameters             | âœ… Yes             | `name â†’ username`, `id â†’ customerId` |
| Convert REST JSON â†’ SOAP XML        | âœ… Yes             | For SOAP backends                    |
| Extract a header and inject to body | âœ… Yes             | Authorization, device ID, etc.       |
| Convert input to match Lambda input | âœ… Yes (non-proxy) | Required when not using AWS_PROXY    |

---

## ğŸ“¦ **Mapping Template Examples**

---

### âœ… Example 1: Rename Query Parameters

<div style="text-align: center;">
    <img src="images/agw-mapping-template-example-1.png" alt="API Gateway Mapping Template Example 1" style="border-radius: 10px; width: 60%;">
</div>

---

**Incoming request:**

```ini
GET /hello?name=foo&other=bar
```

**Mapping Template:**

```vtl
{
  "my_variable": "$input.params('name')",
  "other_variable": "$input.params('other')"
}
```

**Result sent to backend:**

```json
{
  "my_variable": "foo",
  "other_variable": "bar"
}
```

---

### âœ… Example 2: REST (JSON) â†’ SOAP (XML)

<div style="text-align: center;">
    <img src="images/agw-mapping-template-example-2.png" alt="agw-mapping-template-example-2" style="border-radius: 10px; width: 60%;">
</div>

---

**Client Request:**

```json
{
  "orderId": "1234",
  "amount": 99.99
}
```

**Mapping Template:**

```xml
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
   <soapenv:Body>
      <ns1:ProcessOrder xmlns:ns1="http://mycompany.com/soap">
         <orderId>$input.json('$.orderId')</orderId>
         <amount>$input.json('$.amount')</amount>
      </ns1:ProcessOrder>
   </soapenv:Body>
</soapenv:Envelope>
```

âœ… Perfect when youâ€™re integrating **API Gateway with legacy SOAP services**

---

### âœ… Example 3: Add a Header to Backend

```vtl
#set($inputRoot = $input.path('$'))
{
  "userId": "$input.params('userId')",
  "authToken": "$input.params().header.get('Authorization')"
}
```

---

## ğŸ”„ **Response Mapping**

You can also transform the **response from the backend** before returning to the client.

**Example:**

From backend:

```json
{
  "internalId": "abc-123",
  "name": "Hady",
  "password": "secret"
}
```

**Mapping template (response):**

```vtl
{
  "id": "$input.path('$.internalId')",
  "name": "$input.path('$.name')"
}
```

âœ… Result:

```json
{
  "id": "abc-123",
  "name": "Hady"
}
```

ğŸ“Œ Sensitive field (`password`) is stripped!

---

## ğŸ§  Summary Table â€“ Integration Types

| Type         | Backend        | Mapping Templates | Notes                                   |
| ------------ | -------------- | ----------------- | --------------------------------------- |
| `MOCK`       | None           | âœ… Yes            | Return static responses (test/demo)     |
| `HTTP`       | HTTP endpoint  | âœ… Yes            | Call web APIs with full control         |
| `AWS`        | AWS services   | âœ… Yes            | Integrate SQS, DynamoDB, Step Functions |
| `AWS_PROXY`  | Lambda (proxy) | âŒ No             | Simple, all logic in Lambda             |
| `HTTP_PROXY` | HTTP endpoint  | âŒ No             | Fast, raw passthrough                   |

---

## âœ… Best Practices

| Practice                                   | Why Itâ€™s Smart                             |
| ------------------------------------------ | ------------------------------------------ |
| Use `AWS_PROXY` with Lambda for simplicity | You donâ€™t need to write mapping templates  |
| Use mapping for legacy/strict backends     | When backend format doesn't match client   |
| Avoid mapping in `prod` unless needed      | Mapping increases complexity and latency   |
| Use `MOCK` for frontend contract testing   | Design frontend without backend dependency |
