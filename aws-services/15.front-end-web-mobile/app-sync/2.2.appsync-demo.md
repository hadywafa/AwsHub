# ğŸ› ï¸ **Full Guide: Build a Real-Time GraphQL API with AWS AppSync + DynamoDB**

In this step-by-step walkthrough, youâ€™ll build a **real-time Todo API** using **AWS AppSync** (GraphQL) backed by **Amazon DynamoDB**. Youâ€™ll define a schema, connect to data sources, create resolvers, and enable live updates using subscriptions â€” all with **zero backend servers** to manage.

> âœ… Perfect for serverless apps, real-time dashboards, mobile apps, and rapid prototyping.

---

## ğŸ¯ **What You'll Build**

| Feature                         | Description                           |
| ------------------------------- | ------------------------------------- |
| âœ… GraphQL API                  | Queries, mutations, and subscriptions |
| âœ… DynamoDB Integration         | Serverless NoSQL database             |
| âœ… Real-time Subscriptions      | Get updates via WebSockets            |
| âœ… Fully Managed Infrastructure | No servers or scaling to manage       |

---

## ğŸ”§ **1. Create Your AppSync API**

1. Go to **AWS Console â†’ AppSync â†’ Create API**
2. Choose **"Build from Scratch"**
3. Name your API: `TodoAppAPI`
4. Choose **API Key** for demo authentication (donâ€™t use in production)
5. Click **Create**

> ğŸ‰ You now have a managed GraphQL API endpoint!

---

## ğŸ§¬ **2. Define Your GraphQL Schema**

Go to the **Schema** tab and paste the following schema:

```graphql
type Todo {
  id: ID!
  title: String!
  completed: Boolean!
}

type Query {
  getTodo(id: ID!): Todo
  listTodos: [Todo]
}

type Mutation {
  createTodo(title: String!, completed: Boolean!): Todo
  updateTodo(id: ID!, title: String, completed: Boolean): Todo
  deleteTodo(id: ID!): Todo
}

type Subscription {
  onCreateTodo: Todo @aws_subscribe(mutations: ["createTodo"])
}
```

> ğŸ”¹ This schema supports full CRUD operations and real-time updates.

---

## ğŸ—ƒï¸ **3. Create the DynamoDB Table**

1. Go to **AWS Console â†’ DynamoDB â†’ Create Table**
2. Name: `TodosTable`
3. Partition Key: `id` (String)
4. Click **Create**

> ğŸ—‚ï¸ AppSync will use this as the backend database.

---

## ğŸ”— **4. Connect DynamoDB to AppSync**

1. In AppSync, go to **Data Sources â†’ Create Data Source**
2. Choose: **Amazon DynamoDB**
3. Select your table: `TodosTable`
4. Name the source: `TodosTableDataSource`
5. Click **Create**

> ğŸ”Œ Your AppSync API can now read/write to DynamoDB.

---

## ğŸ§  **5. Attach Resolvers (Link GraphQL to DynamoDB)**

Go to **Schema â†’ Resolvers**, then:

### â• `createTodo`

```json
{
  "version": "2018-05-29",
  "operation": "PutItem",
  "key": {
    "id": { "S": "$util.autoId()" }
  },
  "attributeValues": {
    "title": { "S": "$context.arguments.title" },
    "completed": { "BOOL": "$context.arguments.completed" }
  }
}
```

### ğŸ”„ `updateTodo`

```json
{
  "version": "2018-05-29",
  "operation": "UpdateItem",
  "key": {
    "id": { "S": "$context.arguments.id" }
  },
  "update": {
    "expression": "SET #title = :title, #completed = :completed",
    "expressionNames": {
      "#title": "title",
      "#completed": "completed"
    },
    "expressionValues": {
      ":title": { "S": "$context.arguments.title" },
      ":completed": { "BOOL": "$context.arguments.completed" }
    }
  }
}
```

### âŒ `deleteTodo`

```json
{
  "version": "2018-05-29",
  "operation": "DeleteItem",
  "key": {
    "id": { "S": "$context.arguments.id" }
  }
}
```

### ğŸ” `getTodo`

```json
{
  "version": "2018-05-29",
  "operation": "GetItem",
  "key": {
    "id": { "S": "$context.arguments.id" }
  }
}
```

### ğŸ“„ `listTodos`

```json
{
  "version": "2018-05-29",
  "operation": "Scan"
}
```

> ğŸ’¡ No Lambda functions needed â€” this is **pure VTL to DynamoDB** mapping!

---

## ğŸ” **6. Add Real-Time Updates with Subscriptions**

Your schema already includes:

```graphql
type Subscription {
  onCreateTodo: Todo @aws_subscribe(mutations: ["createTodo"])
}
```

Any client subscribed to `onCreateTodo` will receive data **immediately** after a `createTodo` mutation.

---

## ğŸ§ª **7. Test Your API in GraphQL Explorer**

Go to **AppSync â†’ Queries** tab and try:

### â• Create Todo

```graphql
mutation {
  createTodo(title: "Learn AppSync", completed: false) {
    id
    title
    completed
  }
}
```

### ğŸ“„ List Todos

```graphql
query {
  listTodos {
    id
    title
    completed
  }
}
```

### ğŸ”” Subscribe to New Todos

```graphql
subscription {
  onCreateTodo {
    id
    title
    completed
  }
}
```

> âœ… Youâ€™ll get **real-time updates** over WebSockets!

---

## ğŸ” **Securing AppSync (Brief Overview)**

AppSync supports multiple authentication modes:

| Auth Type            | Use Case                                    |
| -------------------- | ------------------------------------------- |
| `API_KEY`            | Demo / testing                              |
| `AWS_IAM`            | Backend-to-backend access (IAM roles)       |
| `COGNITO_USER_POOLS` | Fine-grained user-level control             |
| `OPENID_CONNECT`     | Third-party auth (e.g. Auth0, Google OAuth) |

> ğŸ”’ You can also use **Lambda authorizers** for custom logic.

---

## âœ… **Final Summary**

| âœ… Step               | What You Did                      |
| --------------------- | --------------------------------- |
| 1. Create API         | AppSync API with GraphQL          |
| 2. Define Schema      | Queries, Mutations, Subscriptions |
| 3. Create Table       | DynamoDB as a backend store       |
| 4. Connect to AppSync | Bind data source                  |
| 5. Add Resolvers      | Map GraphQL to DynamoDB with VTL  |
| 6. Subscriptions      | Enable real-time sync             |
| 7. Test the API       | Use GraphQL Explorer              |

---

## ğŸš€ **Next Challenges You Can Explore**

- ğŸ” Add **Cognito authentication** to secure your API
- ğŸ”„ Implement **conflict resolution** and **offline sync** for mobile apps
- ğŸ§  Use **Lambda resolvers** for business logic (e.g., validations)
- ğŸ” Add **search features** using OpenSearch
- ğŸ§ª Set up **unit tests** for your AppSync queries
