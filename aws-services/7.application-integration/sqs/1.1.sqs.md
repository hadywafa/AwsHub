# ğŸ“¬ **Amazon SQS â€“ Mastering Serverless Message Queues**

> _Build scalable, resilient, and decoupled applications with AWS's fully managed message queuing service._

---

<div align="center">
  <img src="images/sqs.png" alt="Amazon SQS" style="border-radius: 10px; width: 80%;" />
</div>

---

## ğŸ§  **What is Amazon SQS?**

**Amazon Simple Queue Service (SQS)** is a fully managed, serverless **message queuing service** that lets components of distributed systems communicate **asynchronously and reliably**.

Whether you're decoupling microservices, offloading long tasks from APIs, or buffering workloads â€” **SQS keeps your systems scalable and fault-tolerant**.

---

## ğŸ” **Key Features at a Glance**

| Feature                | Description                                                         |
| ---------------------- | ------------------------------------------------------------------- |
| âš¡ **Fast & Reliable** | Delivers messages in milliseconds, ensuring no loss during transfer |
| ğŸª¢ **Mechanism**        | It is **Pull Based Mechanism**                                      |
| ğŸ§± **Durable**         | Stores messages across **multiple AZs** within a region             |
| ğŸ”’ **Secure**          | IAM integration for fine-grained access control                     |
| ğŸ› ï¸ **Fully Managed**   | No need to manage infrastructure or scaling                         |
| ğŸ“ˆ **Scalable**        | Scales automatically to handle **millions of messages per second**  |

---

## ğŸŒ€ **Message Lifecycle Overview**

Hereâ€™s how messages move from sender to processor â€” with reliability baked into every step.

### ğŸ” Step-by-Step Flow

<div align="center">

```mermaid
sequenceDiagram
    participant Producer as ğŸ“ Producer
    participant SQS as ğŸ“¨ SQS Queue
    participant Consumer as ğŸ› ï¸ Consumer

    Producer->>SQS: Send message
    SQS->>Consumer: Polls for message
    Consumer->>SQS: Deletes message if success
    alt Failure or timeout
        SQS-->>Consumer: Redelivers message
    end
```

</div>

---

## ğŸ“¤ **1. Message Sending (Producer)**

- Produce Message to SQS using the **SDK (SendMessage API)**
- The message is persisted in SQS **until a consumer deletes it**
- **Single or Batch Send:** Send one message or up to **10 in a batch** _(max 256 KB total)_.
- **Optional Delay:** Use **Delay Queue** feature to delay message delivery _(0 to 15 min)_.

ğŸ’¡ **Example:** After user registration, delay the welcome email by 10 minutes.

---

## ğŸ’¾ **2. Message Storage**

- **Retention Period:** Configurable from **1 minute to 14 days** _(default: 4 days)_.
- Ideal for **retries**, delayed processing, or batching.

---

## ğŸ› ï¸ **3. Message Processing (Consumer)**

- Consumers **poll** the queue to receive messages.
- Poll SQS for messages (receive **up to 10 messages at a time**).
- Delete the messages using the **DeleteMessage API**.

- Choose between:

  - âš¡ **Short Polling** (returns immediately)
  - â³ **Long Polling** (waits up to 20s for new messages â†’ lower cost)

- **Visibility Timeout:**
  Prevents duplicate processing by hiding the message from others while it's being handled.

  - **Default:** 30s | **Max:** 12 hours

âœ… If successful â†’ delete it  
âŒ If failed or not deleted â†’ message becomes visible again

> ğŸ’¡ We can scale consumers horizontally to improve throughput of processing

---

## ğŸ–¼ï¸ **Message Processing (Consumer)**

1. **Retrieve Message:** Consumer fetches a message from the queue.
2. **Lock Message:** The message becomes invisible to other consumers for the duration of the Visibility Timeout.
3. **Process Message:** Consumer processes the message.
4. **Delete Message:** Upon successful processing, the consumer deletes the message from the queue.
5. **Failed Processing:** If the consumer fails to delete the message within the Visibility Timeout, the message becomes visible again for another attempt (ğŸ˜± infinite).

## âŒ **Failure Handling & Dead-Letter Queues (DLQ)**

**Dead Letter Queues (DLQ)** used to Capture messages that fail processing multiple times, aiding in troubleshooting and error handling.

- **Configuration:** Set up a DLQ to receive messages after a specified number of failed processing attempts.

- Set a **maximum receive count** (e.g., 3 attempts).
- After that, message is moved to a **Dead Letter Queue**.
- Great for isolating **poison messages** that break consumers.

---

## ğŸ§± **Queue Types**

### ğŸ”„ 1. **Standard Queue** (default)

| Property   | Details                                      |
| ---------- | -------------------------------------------- |
| Delivery   | At least once                                |
| Order      | Best-effort (not guaranteed)                 |
| Throughput | Nearly unlimited                             |
| Use Case   | High-speed systems where duplicates are okay |

âœ… Example: Log processing, social notifications, telemetry

---

### ğŸ”¢ 2. **FIFO Queue** (First-In-First-Out)

| Property   | Details                               |
| ---------- | ------------------------------------- |
| Delivery   | Exactly once                          |
| Order      | Guaranteed                            |
| Throughput | 300 TPS or 3,000 TPS with batching    |
| Use Case   | Tasks where order & uniqueness matter |

<div align="elft">
  <img src="images/sqs-fifo.gif" alt="FIFO Queue" style="border-radius: 10px; width: 40%;" />
</div>

---

âœ… Example: Payment processing, inventory adjustments

> ğŸ’¡ Ordering by **Message Group ID** (all messages in the same group are ordered) â€“ **mandatory parameter**

---

## ğŸ” **Polling Types**

### âš¡ Short Polling

- Returns instantly (even if no messages)
- More API calls = higher cost

<div align="left" style="padding-left: 30px">
  <img src="images/sqs-short-polling.png" style="border-radius:10px" alt="Short Polling"/>
</div>

---

### âŒ› Long Polling (Recommended)

- Waits up to 20 seconds for new messages
- **Less expensive**, fewer empty responses

<div align="left" style="padding-left: 30px">
  <img src="images/sqs-long-polling.png" style="border-radius:10px" alt="Long Polling"/>
</div>

ğŸ› ï¸ **Configure with:**

- `WaitTimeSeconds` in `ReceiveMessage`
- Or queue-wide setting
- Long polling can be enabled at the queue level or at the API level using WaitTimeSeconds

> ğŸ’¡ LongPolling decreases the number of API calls made to SQS while increasing the efficiency and reducing latency of your application

---

## â³ **Message Visibility Timeout**

<div align="center" style="padding-left: 30px">
  <img src="images/sqs-visibility-timeout.png" style="border-radius:10px; width: 70%;" alt="sqs-visibility-timeout"/>
</div>

---

- After a message is polled by a consumer, it becomes **invisible** to other consumers
- By default, the â€œmessage visibility timeoutâ€ is **30 seconds**, That means the message has **30 seconds** to be re-processed
- After the message visibility timeout is over, the message is **â€œvisibleâ€** in SQS
- If a message is not processed within the visibility timeout, it will be processed twice
- A consumer could call the **ChangeMessageVisibility** API to get more time
- If visibility timeout is high (hours), and consumer crashes, re-processing will take time
- If visibility timeout is too low (seconds), we may get duplicates

## â±ï¸ **Control Timings Like a Pro**

| Feature                | What it Does                                      | Range                                    |
| ---------------------- | ------------------------------------------------- | ---------------------------------------- |
| **Retention**          | How long unprocessed messages stay in queue       | 1 minute â€“ 14 days `(default is 4 days)` |
| **Delay Queue**        | Delay message delivery                            | 0 â€“ 15 minutes `(default is 0)`          |
| **Visibility Timeout** | How long a message is hidden after being received | 0 â€“ 12 hours `(default is 30s)`          |

---

## ğŸ” **Security + Monitoring**

- **IAM Policies**: Control who can send/read/delete messages
- **Encryption**: Supports SSE (S3-like), including SSE-KMS
- **CloudWatch Metrics**: Monitor message age, queue size, DLQ count, etc.
- **X-Ray + Lambda**: Trace message flow through serverless architecture

---

## ğŸ§° **Best Practices**

- âœ… Use **FIFO queues** for workflows needing order
- âœ… Use **long polling** to reduce cost
- âœ… Implement **DLQs** for failed messages
- âœ… Tune **visibility timeout** to match your processing time
- âœ… Enable **encryption at rest (SSE-KMS)**
- âœ… Monitor queue metrics for spikes or dead letters

---

## âœ… **Summary**

| Component             | Purpose                                           |
| --------------------- | ------------------------------------------------- |
| ğŸ¯ SQS                | Decouple components with reliable async messaging |
| ğŸ” Visibility Timeout | Prevent duplicate processing                      |
| â³ Long Polling       | Efficient message retrieval                       |
| ğŸ§¯ DLQ                | Capture failed messages                           |
| ğŸ” IAM & SSE          | Secure access and encrypt data                    |

---

> ğŸ’¡ Amazon SQS is the backbone of **serverless**, **event-driven**, and **decoupled architectures** on AWS. With zero infrastructure management, support for retries and DLQs, and seamless integration with Lambda and Step Functions â€” **SQS lets you focus on logic, not plumbing.**
